/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/apps": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Apps
         * @description List all apps with the ability to filter by organization slug.
         *
         */
        get: operations["Apps_list"];
        put?: never;
        /**
         * Create App
         * @description Create an app with the specified details in the request body.
         *
         */
        post: operations["Apps_create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/{app_name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get App
         * @description Retrieve details about a specific app by its name.
         *
         */
        get: operations["Apps_show"];
        put?: never;
        post?: never;
        /**
         * Destroy App
         * @description Delete an app by its name.
         *
         */
        delete: operations["Apps_delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/{app_name}/deploy_token": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create App deploy token */
        post: operations["App_create_deploy_token"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/{app_name}/machines": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Machines
         * @description List all Machines associated with a specific app, with optional filters for including deleted Machines and filtering by region.
         *
         */
        get: operations["Machines_list"];
        put?: never;
        /**
         * Create Machine
         * @description Create a Machine within a specific app using the details provided in the request body.
         *
         *     **Important**: This request can fail, and you’re responsible for handling that failure. If you ask for a large Machine, or a Machine in a region we happen to be at capacity for, you might need to retry the request, or to fall back to another region. If you’re working directly with the Machines API, you’re taking some responsibility for your own orchestration!
         *
         */
        post: operations["Machines_create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/{app_name}/machines/{machine_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Machine
         * @description Get details of a specific Machine within an app by the Machine ID.
         *
         */
        get: operations["Machines_show"];
        put?: never;
        /**
         * Update Machine
         * @description Update a Machine's configuration using the details provided in the request body.
         *
         */
        post: operations["Machines_update"];
        /**
         * Destroy Machine
         * @description Delete a specific Machine within an app by Machine ID, with an optional force parameter to force kill the Machine if it's running.
         *
         */
        delete: operations["Machines_delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/{app_name}/machines/{machine_id}/cordon": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Cordon Machine
         * @description “Cordoning” a Machine refers to disabling its services, so the Fly Proxy won’t route requests to it. In flyctl this is used by blue/green deployments; one set of Machines is started up with services disabled, and when they are all healthy, the services are enabled on the new Machines and disabled on the old ones.
         *
         */
        post: operations["Machines_cordon"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/{app_name}/machines/{machine_id}/events": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Events
         * @description List all events associated with a specific Machine within an app.
         *
         */
        get: operations["Machines_list_events"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/{app_name}/machines/{machine_id}/exec": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Execute Command
         * @description Execute a command on a specific Machine and return the raw command output bytes.
         *
         */
        post: operations["Machines_exec"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/{app_name}/machines/{machine_id}/lease": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Lease
         * @description Retrieve the current lease of a specific Machine within an app. Machine leases can be used to obtain an exclusive lock on modifying a Machine.
         *
         */
        get: operations["Machines_show_lease"];
        put?: never;
        /**
         * Create Lease
         * @description Create a lease for a specific Machine within an app using the details provided in the request body. Machine leases can be used to obtain an exclusive lock on modifying a Machine.
         *
         */
        post: operations["Machines_create_lease"];
        /**
         * Release Lease
         * @description Release the lease of a specific Machine within an app. Machine leases can be used to obtain an exclusive lock on modifying a Machine.
         *
         */
        delete: operations["Machines_release_lease"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/{app_name}/machines/{machine_id}/metadata": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Metadata
         * @description Retrieve metadata for a specific Machine within an app.
         *
         */
        get: operations["Machines_show_metadata"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/{app_name}/machines/{machine_id}/metadata/{key}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Update Metadata
         * @description Update metadata for a specific machine within an app by providing a metadata key.
         *
         */
        post: operations["Machines_update_metadata"];
        /**
         * Delete Metadata
         * @description Delete metadata for a specific Machine within an app by providing a metadata key.
         *
         */
        delete: operations["Machines_delete_metadata"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/{app_name}/machines/{machine_id}/ps": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Processes
         * @description List all processes running on a specific Machine within an app, with optional sorting parameters.
         *
         */
        get: operations["Machines_list_processes"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/{app_name}/machines/{machine_id}/restart": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Restart Machine
         * @description Restart a specific Machine within an app, with an optional timeout parameter.
         *
         */
        post: operations["Machines_restart"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/{app_name}/machines/{machine_id}/signal": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Signal Machine
         * @description Send a signal to a specific Machine within an app using the details provided in the request body.
         *
         */
        post: operations["Machines_signal"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/{app_name}/machines/{machine_id}/start": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Start Machine
         * @description Start a specific Machine within an app.
         *
         */
        post: operations["Machines_start"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/{app_name}/machines/{machine_id}/stop": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Stop Machine
         * @description Stop a specific Machine within an app, with an optional request body to specify signal and timeout.
         *
         */
        post: operations["Machines_stop"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/{app_name}/machines/{machine_id}/suspend": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Suspend Machine
         * @description Suspend a specific Machine within an app. The next start operation will attempt (but is not guaranteed) to resume the Machine from a snapshot taken at suspension time, rather than performing a cold boot.
         *
         */
        post: operations["Machines_suspend"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/{app_name}/machines/{machine_id}/uncordon": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Uncordon Machine
         * @description “Cordoning” a Machine refers to disabling its services, so the Fly Proxy won’t route requests to it. In flyctl this is used by blue/green deployments; one set of Machines is started up with services disabled, and when they are all healthy, the services are enabled on the new Machines and disabled on the old ones.
         *
         */
        post: operations["Machines_uncordon"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/{app_name}/machines/{machine_id}/versions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Versions
         * @description List all versions of the configuration for a specific Machine within an app.
         *
         */
        get: operations["Machines_list_versions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/{app_name}/machines/{machine_id}/wait": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Wait for State
         * @description Wait for a Machine to reach a specific state. Specify the desired state with the state parameter. See the [Machine states table](https://fly.io/docs/machines/working-with-machines/#machine-states) for a list of possible states. The default for this parameter is `started`.
         *
         *     This request will block for up to 60 seconds. Set a shorter timeout with the timeout parameter.
         *
         */
        get: operations["Machines_wait"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/{app_name}/secretkeys": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List secret keys belonging to an app */
        get: operations["Secretkeys_list"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/{app_name}/secretkeys/{secret_name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get an app's secret key */
        get: operations["Secretkey_get"];
        put?: never;
        /** Create or update a secret key */
        post: operations["Secretkey_set"];
        /** Delete an app's secret key */
        delete: operations["Secretkey_delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/{app_name}/secretkeys/{secret_name}/decrypt": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Decrypt with a secret key */
        post: operations["Secretkey_decrypt"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/{app_name}/secretkeys/{secret_name}/encrypt": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Encrypt with a secret key */
        post: operations["Secretkey_encrypt"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/{app_name}/secretkeys/{secret_name}/generate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Generate a random secret key */
        post: operations["Secretkey_generate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/{app_name}/secretkeys/{secret_name}/sign": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Sign with a secret key */
        post: operations["Secretkey_sign"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/{app_name}/secretkeys/{secret_name}/verify": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Verify with a secret key */
        post: operations["Secretkey_verify"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/{app_name}/secrets": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List app secrets belonging to an app */
        get: operations["Secrets_list"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/{app_name}/secrets/{secret_name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get an app secret */
        get: operations["Secret_get"];
        put?: never;
        /** Create or update Secret */
        post: operations["Secret_create"];
        /** Delete an app secret */
        delete: operations["Secret_delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/{app_name}/volumes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Volumes
         * @description List all volumes associated with a specific app.
         *
         */
        get: operations["Volumes_list"];
        put?: never;
        /**
         * Create Volume
         * @description Create a volume for a specific app using the details provided in the request body.
         *
         */
        post: operations["Volumes_create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/{app_name}/volumes/{volume_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Volume
         * @description Retrieve details about a specific volume by its ID within an app.
         *
         */
        get: operations["Volumes_get_by_id"];
        /**
         * Update Volume
         * @description Update a volume's configuration using the details provided in the request body.
         *
         */
        put: operations["Volumes_update"];
        post?: never;
        /**
         * Destroy Volume
         * @description Delete a specific volume within an app by volume ID.
         *
         */
        delete: operations["Volume_delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/{app_name}/volumes/{volume_id}/extend": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Extend Volume
         * @description Extend a volume's size within an app using the details provided in the request body.
         *
         */
        put: operations["Volumes_extend"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/apps/{app_name}/volumes/{volume_id}/snapshots": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Snapshots
         * @description List all snapshots for a specific volume within an app.
         *
         */
        get: operations["Volumes_list_snapshots"];
        put?: never;
        /**
         * Create Snapshot
         * @description Create a snapshot for a specific volume within an app.
         *
         */
        post: operations["createVolumeSnapshot"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/platform/placements": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get Placements
         * @description Simulates placing the specified number of machines into regions, depending on available capacity and limits.
         */
        post: operations["Platform_placements_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/platform/regions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Regions
         * @description List all regions on the platform with their current Machine capacity.
         */
        get: operations["Platform_regions_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tokens/kms": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Request a Petsem token for accessing KMS
         * @description This site hosts documentation generated from the Fly.io Machines API OpenAPI specification. Visit our complete [Machines API docs](https://fly.io/docs/machines/api/apps-resource/) for details about using the Apps resource.
         */
        post: operations["Tokens_request_Kms"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/tokens/oidc": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Request an OIDC token
         * @description Request an Open ID Connect token for your machine. Customize the audience claim with the `aud` parameter. This returns a JWT token. Learn more about [using OpenID Connect](/docs/reference/openid-connect/) on Fly.io.
         *
         */
        post: operations["Tokens_request_OIDC"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/tokens/current": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Current Token Information
         * @description Get information about the current macaroon token(s), including organizations, apps, and whether each token is from a user or machine
         */
        get: operations["CurrentToken_show"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        App: {
            id?: string;
            name?: string;
            organization?: components["schemas"]["Organization"];
            status?: string;
        };
        AppSecret: {
            digest?: string;
            name?: string;
            value?: string;
        };
        AppSecrets: {
            secrets?: components["schemas"]["AppSecret"][];
        };
        CheckStatus: {
            name?: string;
            output?: string;
            status?: string;
            updated_at?: string;
        };
        CreateAppDeployTokenRequest: {
            expiry?: string;
        };
        CreateAppRequest: {
            app_name?: string;
            enable_subdomains?: boolean;
            network?: string;
            org_slug?: string;
        };
        CreateAppResponse: {
            token?: string;
        };
        CreateLeaseRequest: {
            description?: string;
            /** @description seconds lease will be valid */
            ttl?: number;
        };
        CreateMachineRequest: {
            /** @description An object defining the Machine configuration */
            config?: components["schemas"]["fly.MachineConfig"];
            lease_ttl?: number;
            lsvd?: boolean;
            min_secrets_version?: number;
            /** @description Unique name for this Machine. If omitted, one is generated for you */
            name?: string;
            /** @description The target region. Omitting this param launches in the same region as your WireGuard peer connection (somewhere near you). */
            region?: string;
            skip_launch?: boolean;
            skip_secrets?: boolean;
            skip_service_registration?: boolean;
        };
        /** @description Optional parameters */
        CreateOIDCTokenRequest: {
            /** @example https://fly.io/org-slug */
            aud?: string;
            aws_principal_tags?: boolean;
        };
        CreateVolumeRequest: {
            compute?: components["schemas"]["fly.MachineGuest"];
            compute_image?: string;
            encrypted?: boolean;
            fstype?: string;
            name?: string;
            region?: string;
            require_unique_zone?: boolean;
            size_gb?: number;
            /** @description restore from snapshot */
            snapshot_id?: string;
            snapshot_retention?: number;
            /** @description fork from remote volume */
            source_volume_id?: string;
            unique_zone_app_wide?: boolean;
        };
        CurrentTokenResponse: {
            tokens?: components["schemas"]["main.tokenInfo"][];
        };
        DecryptSecretkeyRequest: {
            associated_data?: number[];
            ciphertext?: number[];
        };
        DecryptSecretkeyResponse: {
            plaintext?: number[];
        };
        EncryptSecretkeyRequest: {
            associated_data?: number[];
            plaintext?: number[];
        };
        EncryptSecretkeyResponse: {
            ciphertext?: number[];
        };
        ErrorResponse: {
            /** @description Deprecated */
            details?: Record<string, never>;
            error?: string;
            status?: components["schemas"]["main.statusCode"];
        };
        ExtendVolumeRequest: {
            size_gb?: number;
        };
        ExtendVolumeResponse: {
            needs_restart?: boolean;
            volume?: components["schemas"]["Volume"];
        };
        ImageRef: {
            digest?: string;
            labels?: {
                [key: string]: string;
            };
            registry?: string;
            repository?: string;
            tag?: string;
        };
        Lease: {
            /** @description Description or reason for the Lease. */
            description?: string;
            /** @description ExpiresAt is the unix timestamp in UTC to denote when the Lease will no longer be valid. */
            expires_at?: number;
            /** @description Nonce is the unique ID autogenerated and associated with the Lease. */
            nonce?: string;
            /** @description Owner is the user identifier which acquired the Lease. */
            owner?: string;
            /** @description Machine version */
            version?: string;
        };
        ListApp: {
            id?: string;
            machine_count?: number;
            name?: string;
            network?: Record<string, never>;
        };
        ListAppsResponse: {
            apps?: components["schemas"]["ListApp"][];
            total_apps?: number;
        };
        ListenSocket: {
            address?: string;
            proto?: string;
        };
        Machine: {
            checks?: components["schemas"]["CheckStatus"][];
            config?: components["schemas"]["fly.MachineConfig"];
            created_at?: string;
            events?: components["schemas"]["MachineEvent"][];
            /** @enum {string} */
            host_status?: "ok" | "unknown" | "unreachable";
            id?: string;
            image_ref?: components["schemas"]["ImageRef"];
            incomplete_config?: components["schemas"]["fly.MachineConfig"];
            /** @description InstanceID is unique for each version of the machine */
            instance_id?: string;
            name?: string;
            /** @description Nonce is only every returned on machine creation if a lease_duration was provided. */
            nonce?: string;
            /** @description PrivateIP is the internal 6PN address of the machine. */
            private_ip?: string;
            region?: string;
            state?: string;
            updated_at?: string;
        };
        MachineEvent: {
            id?: string;
            request?: Record<string, never>;
            source?: string;
            status?: string;
            timestamp?: number;
            type?: string;
        };
        MachineExecRequest: {
            /** @description Deprecated: use Command instead */
            cmd?: string;
            command?: string[];
            container?: string;
            stdin?: string;
            timeout?: number;
        };
        MachineVersion: {
            user_config?: components["schemas"]["fly.MachineConfig"];
            version?: string;
        };
        Organization: {
            name?: string;
            slug?: string;
        };
        ProcessStat: {
            command?: string;
            cpu?: number;
            directory?: string;
            listen_sockets?: components["schemas"]["ListenSocket"][];
            pid?: number;
            rss?: number;
            rtime?: number;
            stime?: number;
        };
        SecretKey: {
            name?: string;
            public_key?: number[];
            type?: string;
        };
        SecretKeys: {
            secret_keys?: components["schemas"]["SecretKey"][];
        };
        SetAppSecretRequest: {
            value?: string;
        };
        SetAppSecretResponse: {
            digest?: string;
            name?: string;
            value?: string;
            version?: number;
        };
        SetSecretkeyRequest: {
            type?: string;
            value?: number[];
        };
        SetSecretkeyResponse: {
            name?: string;
            public_key?: number[];
            type?: string;
            version?: number;
        };
        SignSecretkeyRequest: {
            plaintext?: number[];
        };
        SignSecretkeyResponse: {
            signature?: number[];
        };
        SignalRequest: {
            /** @enum {string} */
            signal?: "SIGABRT" | "SIGALRM" | "SIGFPE" | "SIGHUP" | "SIGILL" | "SIGINT" | "SIGKILL" | "SIGPIPE" | "SIGQUIT" | "SIGSEGV" | "SIGTERM" | "SIGTRAP" | "SIGUSR1";
        };
        StopRequest: {
            signal?: string;
            timeout?: components["schemas"]["fly.Duration"];
        };
        UpdateMachineRequest: {
            /** @description An object defining the Machine configuration */
            config?: components["schemas"]["fly.MachineConfig"];
            current_version?: string;
            lease_ttl?: number;
            lsvd?: boolean;
            min_secrets_version?: number;
            /** @description Unique name for this Machine. If omitted, one is generated for you */
            name?: string;
            /** @description The target region. Omitting this param launches in the same region as your WireGuard peer connection (somewhere near you). */
            region?: string;
            skip_launch?: boolean;
            skip_secrets?: boolean;
            skip_service_registration?: boolean;
        };
        UpdateVolumeRequest: {
            auto_backup_enabled?: boolean;
            snapshot_retention?: number;
        };
        VerifySecretkeyRequest: {
            plaintext?: number[];
            signature?: number[];
        };
        Volume: {
            attached_alloc_id?: string;
            attached_machine_id?: string;
            auto_backup_enabled?: boolean;
            block_size?: number;
            blocks?: number;
            blocks_avail?: number;
            blocks_free?: number;
            bytes_total?: number;
            bytes_used?: number;
            created_at?: string;
            encrypted?: boolean;
            fstype?: string;
            /** @enum {string} */
            host_status?: "ok" | "unknown" | "unreachable";
            id?: string;
            name?: string;
            region?: string;
            size_gb?: number;
            snapshot_retention?: number;
            state?: string;
            zone?: string;
        };
        VolumeSnapshot: {
            created_at?: string;
            digest?: string;
            id?: string;
            retention_days?: number;
            size?: number;
            status?: string;
        };
        "fly.ContainerConfig": {
            /** @description CmdOverride is used to override the default command of the image. */
            cmd?: string[];
            /** @description DependsOn can be used to define dependencies between containers. The container will only be
             *     started after all of its dependent conditions have been satisfied. */
            depends_on?: components["schemas"]["fly.ContainerDependency"][];
            /** @description EntrypointOverride is used to override the default entrypoint of the image. */
            entrypoint?: string[];
            /** @description ExtraEnv is used to add additional environment variables to the container. */
            env?: {
                [key: string]: string;
            };
            /** @description EnvFrom can be provided to set environment variables from machine fields. */
            env_from?: components["schemas"]["fly.EnvFrom"][];
            /** @description Image Config overrides - these fields are used to override the image configuration.
             *     If not provided, the image configuration will be used.
             *     ExecOverride is used to override the default command of the image. */
            exec?: string[];
            /** @description Files are files that will be written to the container file system. */
            files?: components["schemas"]["fly.File"][];
            /** @description Healthchecks determine the health of your containers. Healthchecks can use HTTP, TCP or an Exec command. */
            healthchecks?: components["schemas"]["fly.ContainerHealthcheck"][];
            /** @description Image is the docker image to run. */
            image?: string;
            /** @description Name is used to identify the container in the machine. */
            name?: string;
            /** @description Restart is used to define the restart policy for the container. NOTE: spot-price is not
             *     supported for containers. */
            restart?: components["schemas"]["fly.MachineRestart"];
            /** @description Secrets can be provided at the process level to explicitly indicate which secrets should be
             *     used for the process. If not provided, the secrets provided at the machine level will be used. */
            secrets?: components["schemas"]["fly.MachineSecret"][];
            /** @description Stop is used to define the signal and timeout for stopping the container. */
            stop?: components["schemas"]["fly.StopConfig"];
            /** @description UserOverride is used to override the default user of the image. */
            user?: string;
        };
        "fly.ContainerDependency": {
            condition?: components["schemas"]["fly.ContainerDependencyCondition"];
            name?: string;
        };
        /** @enum {string} */
        "fly.ContainerDependencyCondition": "exited_successfully" | "healthy" | "started";
        "fly.ContainerHealthcheck": {
            exec?: components["schemas"]["fly.ExecHealthcheck"];
            /** @description The number of times the check must fail before considering the container unhealthy. */
            failure_threshold?: number;
            /** @description The time in seconds to wait after a container starts before checking its health. */
            grace_period?: number;
            http?: components["schemas"]["fly.HTTPHealthcheck"];
            /** @description The time in seconds between executing the defined check. */
            interval?: number;
            /** @description Kind of healthcheck (readiness, liveness) */
            kind?: components["schemas"]["fly.ContainerHealthcheckKind"];
            /** @description The name of the check. Must be unique within the container. */
            name?: string;
            /** @description The number of times the check must succeeed before considering the container healthy. */
            success_threshold?: number;
            tcp?: components["schemas"]["fly.TCPHealthcheck"];
            /** @description The time in seconds to wait for the check to complete. */
            timeout?: number;
            /** @description Unhealthy policy that determines what action to take if a container is deemed unhealthy */
            unhealthy?: components["schemas"]["fly.UnhealthyPolicy"];
        };
        /** @enum {string} */
        "fly.ContainerHealthcheckKind": "readiness" | "liveness";
        /** @enum {string} */
        "fly.ContainerHealthcheckScheme": "http" | "https";
        "fly.DNSConfig": {
            dns_forward_rules?: components["schemas"]["fly.dnsForwardRule"][];
            hostname?: string;
            hostname_fqdn?: string;
            nameservers?: string[];
            options?: components["schemas"]["fly.dnsOption"][];
            searches?: string[];
            skip_registration?: boolean;
        };
        "fly.Duration": {
            "time.Duration"?: number;
        };
        /** @description EnvVar defines an environment variable to be populated from a machine field, env_var */
        "fly.EnvFrom": {
            /** @description EnvVar is required and is the name of the environment variable that will be set from the
             *     secret. It must be a valid environment variable name. */
            env_var?: string;
            /**
             * @description FieldRef selects a field of the Machine: supports id, version, app_name, private_ip, region, image.
             * @enum {string}
             */
            field_ref?: "id" | "version" | "app_name" | "private_ip" | "region" | "image";
        };
        "fly.ExecHealthcheck": {
            /** @description The command to run to check the health of the container (e.g. ["cat", "/tmp/healthy"]) */
            command?: string[];
        };
        /** @description A file that will be written to the Machine. One of RawValue or SecretName must be set. */
        "fly.File": {
            /** @description GuestPath is the path on the machine where the file will be written and must be an absolute path.
             *     For example: /full/path/to/file.json */
            guest_path?: string;
            /** @description The name of an image to use the OCI image config as the file contents. */
            image_config?: string;
            /** @description Mode bits used to set permissions on this file as accepted by chmod(2). */
            mode?: number;
            /** @description The base64 encoded string of the file contents. */
            raw_value?: string;
            /** @description The name of the secret that contains the base64 encoded file contents. */
            secret_name?: string;
        };
        "fly.HTTPHealthcheck": {
            /** @description Additional headers to send with the request */
            headers?: components["schemas"]["fly.MachineHTTPHeader"][];
            /** @description The HTTP method to use to when making the request */
            method?: string;
            /** @description The path to send the request to */
            path?: string;
            /** @description The port to connect to, often the same as internal_port */
            port?: number;
            /** @description Whether to use http or https */
            scheme?: components["schemas"]["fly.ContainerHealthcheckScheme"];
            /** @description If the protocol is https, the hostname to use for TLS certificate validation */
            tls_server_name?: string;
            /** @description If the protocol is https, whether or not to verify the TLS certificate */
            tls_skip_verify?: boolean;
        };
        "fly.HTTPOptions": {
            compress?: boolean;
            h2_backend?: boolean;
            headers_read_timeout?: number;
            idle_timeout?: number;
            response?: components["schemas"]["fly.HTTPResponseOptions"];
        };
        "fly.HTTPResponseOptions": {
            headers?: {
                [key: string]: Record<string, never>;
            };
            pristine?: boolean;
        };
        "fly.MachineCheck": {
            /** @description The time to wait after a VM starts before checking its health */
            grace_period?: components["schemas"]["fly.Duration"];
            headers?: components["schemas"]["fly.MachineHTTPHeader"][];
            /** @description The time between connectivity checks */
            interval?: components["schemas"]["fly.Duration"];
            /**
             * @description Kind of the check (informational, readiness)
             * @enum {string}
             */
            kind?: "informational" | "readiness";
            /** @description For http checks, the HTTP method to use to when making the request */
            method?: string;
            /** @description For http checks, the path to send the request to */
            path?: string;
            /** @description The port to connect to, often the same as internal_port */
            port?: number;
            /** @description For http checks, whether to use http or https */
            protocol?: string;
            /** @description The maximum time a connection can take before being reported as failing its health check */
            timeout?: components["schemas"]["fly.Duration"];
            /** @description If the protocol is https, the hostname to use for TLS certificate validation */
            tls_server_name?: string;
            /** @description For http checks with https protocol, whether or not to verify the TLS certificate */
            tls_skip_verify?: boolean;
            /** @description tcp or http */
            type?: string;
        };
        "fly.MachineConfig": {
            /** @description Optional boolean telling the Machine to destroy itself once it’s complete (default false) */
            auto_destroy?: boolean;
            /** @description An optional object that defines one or more named top-level checks. The key for each check is the check name. */
            checks?: {
                [key: string]: components["schemas"]["fly.MachineCheck"];
            };
            /** @description Containers are a list of containers that will run in the machine. Currently restricted to
             *     only specific organizations. */
            containers?: components["schemas"]["fly.ContainerConfig"][];
            /** @description Deprecated: use Service.Autostart instead */
            disable_machine_autostart?: boolean;
            dns?: components["schemas"]["fly.DNSConfig"];
            /** @description An object filled with key/value pairs to be set as environment variables */
            env?: {
                [key: string]: string;
            };
            files?: components["schemas"]["fly.File"][];
            guest?: components["schemas"]["fly.MachineGuest"];
            /** @description The docker image to run */
            image?: string;
            init?: components["schemas"]["fly.MachineInit"];
            metadata?: {
                [key: string]: string;
            };
            metrics?: components["schemas"]["fly.MachineMetrics"];
            mounts?: components["schemas"]["fly.MachineMount"][];
            processes?: components["schemas"]["fly.MachineProcess"][];
            restart?: components["schemas"]["fly.MachineRestart"];
            schedule?: string;
            services?: components["schemas"]["fly.MachineService"][];
            /** @description Deprecated: use Guest instead */
            size?: string;
            /** @description Standbys enable a machine to be a standby for another. In the event of a hardware failure,
             *     the standby machine will be started. */
            standbys?: string[];
            statics?: components["schemas"]["fly.Static"][];
            stop_config?: components["schemas"]["fly.StopConfig"];
        };
        "fly.MachineGuest": {
            cpu_kind?: string;
            cpus?: number;
            gpu_kind?: string;
            gpus?: number;
            host_dedication_id?: string;
            kernel_args?: string[];
            memory_mb?: number;
        };
        /** @description For http checks, an array of objects with string field Name and array of strings field Values. The key/value pairs specify header and header values that will get passed with the check call. */
        "fly.MachineHTTPHeader": {
            /** @description The header name */
            name?: string;
            /** @description The header value */
            values?: string[];
        };
        "fly.MachineInit": {
            cmd?: string[];
            entrypoint?: string[];
            exec?: string[];
            kernel_args?: string[];
            swap_size_mb?: number;
            tty?: boolean;
        };
        "fly.MachineMetrics": {
            https?: boolean;
            path?: string;
            port?: number;
        };
        "fly.MachineMount": {
            add_size_gb?: number;
            encrypted?: boolean;
            extend_threshold_percent?: number;
            name?: string;
            path?: string;
            size_gb?: number;
            size_gb_limit?: number;
            volume?: string;
        };
        "fly.MachinePort": {
            end_port?: number;
            force_https?: boolean;
            handlers?: string[];
            http_options?: components["schemas"]["fly.HTTPOptions"];
            port?: number;
            proxy_proto_options?: components["schemas"]["fly.ProxyProtoOptions"];
            start_port?: number;
            tls_options?: components["schemas"]["fly.TLSOptions"];
        };
        "fly.MachineProcess": {
            cmd?: string[];
            entrypoint?: string[];
            env?: {
                [key: string]: string;
            };
            /** @description EnvFrom can be provided to set environment variables from machine fields. */
            env_from?: components["schemas"]["fly.EnvFrom"][];
            exec?: string[];
            /** @description IgnoreAppSecrets can be set to true to ignore the secrets for the App the Machine belongs to
             *     and only use the secrets provided at the process level. The default/legacy behavior is to use
             *     the secrets provided at the App level. */
            ignore_app_secrets?: boolean;
            /** @description Secrets can be provided at the process level to explicitly indicate which secrets should be
             *     used for the process. If not provided, the secrets provided at the machine level will be used. */
            secrets?: components["schemas"]["fly.MachineSecret"][];
            user?: string;
        };
        /** @description The Machine restart policy defines whether and how flyd restarts a Machine after its main process exits. See https://fly.io/docs/machines/guides-examples/machine-restart-policy/. */
        "fly.MachineRestart": {
            /** @description GPU bid price for spot Machines. */
            gpu_bid_price?: number;
            /** @description When policy is on-failure, the maximum number of times to attempt to restart the Machine before letting it stop. */
            max_retries?: number;
            /**
             * @description * no - Never try to restart a Machine automatically when its main process exits, whether that’s on purpose or on a crash.
             *     * always - Always restart a Machine automatically and never let it enter a stopped state, even when the main process exits cleanly.
             *     * on-failure - Try up to MaxRetries times to automatically restart the Machine if it exits with a non-zero exit code. Default when no explicit policy is set, and for Machines with schedules.
             *     * spot-price - Starts the Machine only when there is capacity and the spot price is less than or equal to the bid price.
             * @enum {string}
             */
            policy?: "no" | "always" | "on-failure" | "spot-price";
        };
        /** @description A Secret needing to be set in the environment of the Machine. env_var is required */
        "fly.MachineSecret": {
            /** @description EnvVar is required and is the name of the environment variable that will be set from the
             *     secret. It must be a valid environment variable name. */
            env_var?: string;
            /** @description Name is optional and when provided is used to reference a secret name where the EnvVar is
             *     different from what was set as the secret name. */
            name?: string;
        };
        "fly.MachineService": {
            autostart?: boolean;
            /**
             * @description Accepts a string (new format) or a boolean (old format). For backward compatibility with older clients, the API continues to use booleans for "off" and "stop" in responses.
             *     * "off" or false - Do not autostop the Machine.
             *     * "stop" or true - Automatically stop the Machine.
             *     * "suspend" - Automatically suspend the Machine, falling back to a full stop if this is not possible.
             * @enum {string}
             */
            autostop?: "off" | "stop" | "suspend";
            /** @description An optional list of service checks */
            checks?: components["schemas"]["fly.MachineServiceCheck"][];
            concurrency?: components["schemas"]["fly.MachineServiceConcurrency"];
            force_instance_description?: string;
            force_instance_key?: string;
            internal_port?: number;
            min_machines_running?: number;
            ports?: components["schemas"]["fly.MachinePort"][];
            protocol?: string;
        };
        "fly.MachineServiceCheck": {
            /** @description The time to wait after a VM starts before checking its health */
            grace_period?: components["schemas"]["fly.Duration"];
            headers?: components["schemas"]["fly.MachineHTTPHeader"][];
            /** @description The time between connectivity checks */
            interval?: components["schemas"]["fly.Duration"];
            /** @description For http checks, the HTTP method to use to when making the request */
            method?: string;
            /** @description For http checks, the path to send the request to */
            path?: string;
            /** @description The port to connect to, often the same as internal_port */
            port?: number;
            /** @description For http checks, whether to use http or https */
            protocol?: string;
            /** @description The maximum time a connection can take before being reported as failing its health check */
            timeout?: components["schemas"]["fly.Duration"];
            /** @description If the protocol is https, the hostname to use for TLS certificate validation */
            tls_server_name?: string;
            /** @description For http checks with https protocol, whether or not to verify the TLS certificate */
            tls_skip_verify?: boolean;
            /** @description tcp or http */
            type?: string;
        };
        "fly.MachineServiceConcurrency": {
            hard_limit?: number;
            soft_limit?: number;
            type?: string;
        };
        "fly.ProxyProtoOptions": {
            version?: string;
        };
        "fly.Static": {
            guest_path: string;
            index_document?: string;
            tigris_bucket?: string;
            url_prefix: string;
        };
        "fly.StopConfig": {
            signal?: string;
            timeout?: components["schemas"]["fly.Duration"];
        };
        "fly.TCPHealthcheck": {
            /** @description The port to connect to, often the same as internal_port */
            port?: number;
        };
        "fly.TLSOptions": {
            alpn?: string[];
            default_self_signed?: boolean;
            versions?: string[];
        };
        /** @enum {string} */
        "fly.UnhealthyPolicy": "stop";
        "fly.dnsForwardRule": {
            addr?: string;
            basename?: string;
        };
        "fly.dnsOption": {
            name?: string;
            value?: string;
        };
        "flydv1.ExecResponse": {
            exit_code?: number;
            exit_signal?: number;
            stderr?: string;
            stdout?: string;
        };
        "main.getPlacementsRequest": {
            /** @description Resource requirements for the Machine to simulate. Defaults to a performance-1x machine */
            compute?: components["schemas"]["fly.MachineGuest"];
            /** @description Number of machines to simulate placement.
             *     Defaults to 0, which returns the org-specific limit for each region. */
            count?: number;
            /** @example personal */
            org_slug: string;
            /**
             * @description Region expression for placement as a comma-delimited set of regions or aliases.
             *     Defaults to "[region],any", to prefer the API endpoint's local region with any other region as fallback.
             * @example lhr,eu
             */
            region?: string;
            /** @example  */
            volume_name?: string;
            volume_size_bytes?: number;
            /**
             * @description Optional weights to override default placement preferences.
             * @example {
             *       "region": 1000,
             *       "spread": 0
             *     }
             */
            weights?: components["schemas"]["placement.Weights"];
        };
        "main.getPlacementsResponse": {
            regions?: components["schemas"]["placement.RegionPlacement"][];
        };
        "main.regionResponse": {
            regions?: components["schemas"]["reads.GetCapacityPerRegionRow"][];
        };
        /** @enum {string} */
        "main.statusCode": "unknown" | "insufficient_capacity";
        "main.tokenInfo": {
            apps?: string[];
            org_slug?: string;
            organization?: string;
            /** @description Machine the token is restricted to (FromMachine caveat) */
            restricted_to_machine?: string;
            /** @description Machine making the request */
            source_machine_id?: string;
            token_id?: string;
            /** @description User identifier if token is for a user */
            user?: string;
        };
        "placement.RegionPlacement": {
            /** @description Hint on the number of machines in this region can be created concurrently.
             *     Equal to the number of unique hosts selected for placement. */
            concurrency?: number;
            count?: number;
            region?: string;
        };
        "placement.Weights": {
            [key: string]: number;
        };
        "reads.GetCapacityPerRegionRow": {
            capacity?: number;
            code?: string;
            gateway_available?: boolean;
            geo_region?: string;
            latitude?: number;
            longitude?: number;
            name?: string;
            requires_paid_plan?: boolean;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type SchemaApp = components['schemas']['App'];
export type SchemaAppSecret = components['schemas']['AppSecret'];
export type SchemaAppSecrets = components['schemas']['AppSecrets'];
export type SchemaCheckStatus = components['schemas']['CheckStatus'];
export type SchemaCreateAppDeployTokenRequest = components['schemas']['CreateAppDeployTokenRequest'];
export type SchemaCreateAppRequest = components['schemas']['CreateAppRequest'];
export type SchemaCreateAppResponse = components['schemas']['CreateAppResponse'];
export type SchemaCreateLeaseRequest = components['schemas']['CreateLeaseRequest'];
export type SchemaCreateMachineRequest = components['schemas']['CreateMachineRequest'];
export type SchemaCreateOidcTokenRequest = components['schemas']['CreateOIDCTokenRequest'];
export type SchemaCreateVolumeRequest = components['schemas']['CreateVolumeRequest'];
export type SchemaCurrentTokenResponse = components['schemas']['CurrentTokenResponse'];
export type SchemaDecryptSecretkeyRequest = components['schemas']['DecryptSecretkeyRequest'];
export type SchemaDecryptSecretkeyResponse = components['schemas']['DecryptSecretkeyResponse'];
export type SchemaEncryptSecretkeyRequest = components['schemas']['EncryptSecretkeyRequest'];
export type SchemaEncryptSecretkeyResponse = components['schemas']['EncryptSecretkeyResponse'];
export type SchemaErrorResponse = components['schemas']['ErrorResponse'];
export type SchemaExtendVolumeRequest = components['schemas']['ExtendVolumeRequest'];
export type SchemaExtendVolumeResponse = components['schemas']['ExtendVolumeResponse'];
export type SchemaImageRef = components['schemas']['ImageRef'];
export type SchemaLease = components['schemas']['Lease'];
export type SchemaListApp = components['schemas']['ListApp'];
export type SchemaListAppsResponse = components['schemas']['ListAppsResponse'];
export type SchemaListenSocket = components['schemas']['ListenSocket'];
export type SchemaMachine = components['schemas']['Machine'];
export type SchemaMachineEvent = components['schemas']['MachineEvent'];
export type SchemaMachineExecRequest = components['schemas']['MachineExecRequest'];
export type SchemaMachineVersion = components['schemas']['MachineVersion'];
export type SchemaOrganization = components['schemas']['Organization'];
export type SchemaProcessStat = components['schemas']['ProcessStat'];
export type SchemaSecretKey = components['schemas']['SecretKey'];
export type SchemaSecretKeys = components['schemas']['SecretKeys'];
export type SchemaSetAppSecretRequest = components['schemas']['SetAppSecretRequest'];
export type SchemaSetAppSecretResponse = components['schemas']['SetAppSecretResponse'];
export type SchemaSetSecretkeyRequest = components['schemas']['SetSecretkeyRequest'];
export type SchemaSetSecretkeyResponse = components['schemas']['SetSecretkeyResponse'];
export type SchemaSignSecretkeyRequest = components['schemas']['SignSecretkeyRequest'];
export type SchemaSignSecretkeyResponse = components['schemas']['SignSecretkeyResponse'];
export type SchemaSignalRequest = components['schemas']['SignalRequest'];
export type SchemaStopRequest = components['schemas']['StopRequest'];
export type SchemaUpdateMachineRequest = components['schemas']['UpdateMachineRequest'];
export type SchemaUpdateVolumeRequest = components['schemas']['UpdateVolumeRequest'];
export type SchemaVerifySecretkeyRequest = components['schemas']['VerifySecretkeyRequest'];
export type SchemaVolume = components['schemas']['Volume'];
export type SchemaVolumeSnapshot = components['schemas']['VolumeSnapshot'];
export type SchemaFlyContainerConfig = components['schemas']['fly.ContainerConfig'];
export type SchemaFlyContainerDependency = components['schemas']['fly.ContainerDependency'];
export type SchemaFlyContainerDependencyCondition = components['schemas']['fly.ContainerDependencyCondition'];
export type SchemaFlyContainerHealthcheck = components['schemas']['fly.ContainerHealthcheck'];
export type SchemaFlyContainerHealthcheckKind = components['schemas']['fly.ContainerHealthcheckKind'];
export type SchemaFlyContainerHealthcheckScheme = components['schemas']['fly.ContainerHealthcheckScheme'];
export type SchemaFlyDnsConfig = components['schemas']['fly.DNSConfig'];
export type SchemaFlyDuration = components['schemas']['fly.Duration'];
export type SchemaFlyEnvFrom = components['schemas']['fly.EnvFrom'];
export type SchemaFlyExecHealthcheck = components['schemas']['fly.ExecHealthcheck'];
export type SchemaFlyFile = components['schemas']['fly.File'];
export type SchemaFlyHttpHealthcheck = components['schemas']['fly.HTTPHealthcheck'];
export type SchemaFlyHttpOptions = components['schemas']['fly.HTTPOptions'];
export type SchemaFlyHttpResponseOptions = components['schemas']['fly.HTTPResponseOptions'];
export type SchemaFlyMachineCheck = components['schemas']['fly.MachineCheck'];
export type SchemaFlyMachineConfig = components['schemas']['fly.MachineConfig'];
export type SchemaFlyMachineGuest = components['schemas']['fly.MachineGuest'];
export type SchemaFlyMachineHttpHeader = components['schemas']['fly.MachineHTTPHeader'];
export type SchemaFlyMachineInit = components['schemas']['fly.MachineInit'];
export type SchemaFlyMachineMetrics = components['schemas']['fly.MachineMetrics'];
export type SchemaFlyMachineMount = components['schemas']['fly.MachineMount'];
export type SchemaFlyMachinePort = components['schemas']['fly.MachinePort'];
export type SchemaFlyMachineProcess = components['schemas']['fly.MachineProcess'];
export type SchemaFlyMachineRestart = components['schemas']['fly.MachineRestart'];
export type SchemaFlyMachineSecret = components['schemas']['fly.MachineSecret'];
export type SchemaFlyMachineService = components['schemas']['fly.MachineService'];
export type SchemaFlyMachineServiceCheck = components['schemas']['fly.MachineServiceCheck'];
export type SchemaFlyMachineServiceConcurrency = components['schemas']['fly.MachineServiceConcurrency'];
export type SchemaFlyProxyProtoOptions = components['schemas']['fly.ProxyProtoOptions'];
export type SchemaFlyStatic = components['schemas']['fly.Static'];
export type SchemaFlyStopConfig = components['schemas']['fly.StopConfig'];
export type SchemaFlyTcpHealthcheck = components['schemas']['fly.TCPHealthcheck'];
export type SchemaFlyTlsOptions = components['schemas']['fly.TLSOptions'];
export type SchemaFlyUnhealthyPolicy = components['schemas']['fly.UnhealthyPolicy'];
export type SchemaFlyDnsForwardRule = components['schemas']['fly.dnsForwardRule'];
export type SchemaFlyDnsOption = components['schemas']['fly.dnsOption'];
export type SchemaFlydv1ExecResponse = components['schemas']['flydv1.ExecResponse'];
export type SchemaMainGetPlacementsRequest = components['schemas']['main.getPlacementsRequest'];
export type SchemaMainGetPlacementsResponse = components['schemas']['main.getPlacementsResponse'];
export type SchemaMainRegionResponse = components['schemas']['main.regionResponse'];
export type SchemaMainStatusCode = components['schemas']['main.statusCode'];
export type SchemaMainTokenInfo = components['schemas']['main.tokenInfo'];
export type SchemaPlacementRegionPlacement = components['schemas']['placement.RegionPlacement'];
export type SchemaPlacementWeights = components['schemas']['placement.Weights'];
export type SchemaReadsGetCapacityPerRegionRow = components['schemas']['reads.GetCapacityPerRegionRow'];
export type $defs = Record<string, never>;
export interface operations {
    Apps_list: {
        parameters: {
            query: {
                /** @description The org slug, or 'personal', to filter apps */
                org_slug: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListAppsResponse"];
                };
            };
        };
    };
    Apps_create: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description App body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateAppRequest"];
            };
        };
        responses: {
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    Apps_show: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["App"];
                };
            };
        };
    };
    Apps_delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Accepted */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    App_create_deploy_token: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
            };
            cookie?: never;
        };
        /** @description Request body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateAppDeployTokenRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CreateAppResponse"];
                };
            };
        };
    };
    Machines_list: {
        parameters: {
            query?: {
                /** @description Include deleted machines */
                include_deleted?: boolean;
                /** @description Region filter */
                region?: string;
                /** @description comma separated list of states to filter (created, started, stopped, suspended) */
                state?: string;
                /** @description Only return summary info about machines (omit config, checks, events, host_status, nonce, etc.) */
                summary?: boolean;
            };
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Machine"][];
                };
            };
        };
    };
    Machines_create: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
            };
            cookie?: never;
        };
        /** @description Create machine request */
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateMachineRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Machine"];
                };
            };
        };
    };
    Machines_show: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description Machine ID */
                machine_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Machine"];
                };
            };
        };
    };
    Machines_update: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description Machine ID */
                machine_id: string;
            };
            cookie?: never;
        };
        /** @description Request body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateMachineRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Machine"];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    Machines_delete: {
        parameters: {
            query?: {
                /** @description Force kill the machine if it's running */
                force?: boolean;
            };
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description Machine ID */
                machine_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    Machines_cordon: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description Machine ID */
                machine_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    Machines_list_events: {
        parameters: {
            query?: {
                /** @description The number of events to fetch (max of 50). If omitted, this is set to 20 by default. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description Machine ID */
                machine_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MachineEvent"][];
                };
            };
        };
    };
    Machines_exec: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description Machine ID */
                machine_id: string;
            };
            cookie?: never;
        };
        /** @description Request body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MachineExecRequest"];
            };
        };
        responses: {
            /** @description stdout, stderr, exit code, and exit signal are returned */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/octet-stream": components["schemas"]["flydv1.ExecResponse"];
                    "application/json": components["schemas"]["flydv1.ExecResponse"];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/octet-stream": components["schemas"]["ErrorResponse"];
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    Machines_show_lease: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description Machine ID */
                machine_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Lease"];
                };
            };
        };
    };
    Machines_create_lease: {
        parameters: {
            query?: never;
            header?: {
                /** @description Existing lease nonce to refresh by ttl, empty or non-existent to create a new lease */
                "fly-machine-lease-nonce"?: string;
            };
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description Machine ID */
                machine_id: string;
            };
            cookie?: never;
        };
        /** @description Request body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateLeaseRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Lease"];
                };
            };
        };
    };
    Machines_release_lease: {
        parameters: {
            query?: never;
            header: {
                /** @description Existing lease nonce */
                "fly-machine-lease-nonce": string;
            };
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description Machine ID */
                machine_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    Machines_show_metadata: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description Machine ID */
                machine_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        [key: string]: string;
                    };
                };
            };
        };
    };
    Machines_update_metadata: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description Machine ID */
                machine_id: string;
                /** @description Metadata Key */
                key: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No Content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    Machines_delete_metadata: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description Machine ID */
                machine_id: string;
                /** @description Metadata Key */
                key: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No Content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    Machines_list_processes: {
        parameters: {
            query?: {
                /** @description Sort by */
                sort_by?: string;
                /** @description Order */
                order?: string;
            };
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description Machine ID */
                machine_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProcessStat"][];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    Machines_restart: {
        parameters: {
            query?: {
                /** @description Restart timeout as a Go duration string or number of seconds */
                timeout?: string;
                /** @description Unix signal name */
                signal?: string;
            };
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description Machine ID */
                machine_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    Machines_signal: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description Machine ID */
                machine_id: string;
            };
            cookie?: never;
        };
        /** @description Request body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["SignalRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    Machines_start: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description Machine ID */
                machine_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    Machines_stop: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description Machine ID */
                machine_id: string;
            };
            cookie?: never;
        };
        /** @description Optional request body */
        requestBody?: {
            content: {
                "application/json": components["schemas"]["StopRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    Machines_suspend: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description Machine ID */
                machine_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    Machines_uncordon: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description Machine ID */
                machine_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    Machines_list_versions: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description Machine ID */
                machine_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MachineVersion"][];
                };
            };
        };
    };
    Machines_wait: {
        parameters: {
            query?: {
                /** @description 26-character Machine version ID */
                instance_id?: string;
                /** @description wait timeout. default 60s */
                timeout?: number;
                /** @description desired state */
                state?: "started" | "stopped" | "suspended" | "destroyed";
            };
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description Machine ID */
                machine_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    Secretkeys_list: {
        parameters: {
            query?: {
                /** @description Minimum secrets version to return. Returned when setting a new secret */
                min_version?: string;
                /** @description Comma-seperated list of secret keys to list */
                types?: string;
            };
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SecretKeys"];
                };
            };
        };
    };
    Secretkey_get: {
        parameters: {
            query?: {
                /** @description Minimum secrets version to return. Returned when setting a new secret */
                min_version?: string;
            };
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description Secret key name */
                secret_name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SecretKey"];
                };
            };
        };
    };
    Secretkey_set: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description Secret key name */
                secret_name: string;
            };
            cookie?: never;
        };
        /** @description Create secret key request */
        requestBody: {
            content: {
                "application/json": components["schemas"]["SetSecretkeyRequest"];
            };
        };
        responses: {
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SetSecretkeyResponse"];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    Secretkey_delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description Secret key name */
                secret_name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No Content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    Secretkey_decrypt: {
        parameters: {
            query?: {
                /** @description Minimum secrets version to return. Returned when setting a new secret */
                min_version?: string;
            };
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description Secret key name */
                secret_name: string;
            };
            cookie?: never;
        };
        /** @description Decrypt with secret key request */
        requestBody: {
            content: {
                "application/json": components["schemas"]["DecryptSecretkeyRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DecryptSecretkeyResponse"];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    Secretkey_encrypt: {
        parameters: {
            query?: {
                /** @description Minimum secrets version to return. Returned when setting a new secret */
                min_version?: string;
            };
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description Secret key name */
                secret_name: string;
            };
            cookie?: never;
        };
        /** @description Encrypt with secret key request */
        requestBody: {
            content: {
                "application/json": components["schemas"]["EncryptSecretkeyRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EncryptSecretkeyResponse"];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    Secretkey_generate: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description Secret key name */
                secret_name: string;
            };
            cookie?: never;
        };
        /** @description generate secret key request */
        requestBody: {
            content: {
                "application/json": components["schemas"]["SetSecretkeyRequest"];
            };
        };
        responses: {
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SetSecretkeyResponse"];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    Secretkey_sign: {
        parameters: {
            query?: {
                /** @description Minimum secrets version to return. Returned when setting a new secret */
                min_version?: string;
            };
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description Secret key name */
                secret_name: string;
            };
            cookie?: never;
        };
        /** @description Sign with secret key request */
        requestBody: {
            content: {
                "application/json": components["schemas"]["SignSecretkeyRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SignSecretkeyResponse"];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    Secretkey_verify: {
        parameters: {
            query?: {
                /** @description Minimum secrets version to return. Returned when setting a new secret */
                min_version?: string;
            };
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description Secret key name */
                secret_name: string;
            };
            cookie?: never;
        };
        /** @description Verify with secret key request */
        requestBody: {
            content: {
                "application/json": components["schemas"]["VerifySecretkeyRequest"];
            };
        };
        responses: {
            /** @description No Content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    Secrets_list: {
        parameters: {
            query?: {
                /** @description Minimum secrets version to return. Returned when setting a new secret */
                min_version?: string;
                /** @description Show the secret values. */
                show_secrets?: boolean;
            };
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AppSecrets"];
                };
            };
        };
    };
    Secret_get: {
        parameters: {
            query?: {
                /** @description Minimum secrets version to return. Returned when setting a new secret */
                min_version?: string;
                /** @description Show the secret value. */
                show_secrets?: boolean;
            };
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description App secret name */
                secret_name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AppSecret"];
                };
            };
        };
    };
    Secret_create: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description App secret name */
                secret_name: string;
            };
            cookie?: never;
        };
        /** @description Create app secret request */
        requestBody: {
            content: {
                "application/json": components["schemas"]["SetAppSecretRequest"];
            };
        };
        responses: {
            /** @description Created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SetAppSecretResponse"];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    Secret_delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description App secret name */
                secret_name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description No Content */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    Volumes_list: {
        parameters: {
            query?: {
                /** @description Only return summary info about volumes (omit blocks, block size, etc) */
                summary?: boolean;
            };
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Volume"][];
                };
            };
        };
    };
    Volumes_create: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
            };
            cookie?: never;
        };
        /** @description Request body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateVolumeRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Volume"];
                };
            };
        };
    };
    Volumes_get_by_id: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description Volume ID */
                volume_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Volume"];
                };
            };
        };
    };
    Volumes_update: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description Volume ID */
                volume_id: string;
            };
            cookie?: never;
        };
        /** @description Request body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateVolumeRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Volume"];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    Volume_delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description Volume ID */
                volume_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Volume"];
                };
            };
        };
    };
    Volumes_extend: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description Volume ID */
                volume_id: string;
            };
            cookie?: never;
        };
        /** @description Request body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ExtendVolumeRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ExtendVolumeResponse"];
                };
            };
        };
    };
    Volumes_list_snapshots: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description Volume ID */
                volume_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["VolumeSnapshot"][];
                };
            };
        };
    };
    createVolumeSnapshot: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Fly App Name */
                app_name: string;
                /** @description Volume ID */
                volume_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    Platform_placements_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get placements request */
        requestBody: {
            content: {
                "application/json": components["schemas"]["main.getPlacementsRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["main.getPlacementsResponse"];
                };
            };
        };
    };
    Platform_regions_get: {
        parameters: {
            query?: {
                /** @description guest machine size preset. default performance-1x */
                size?: string;
                /** @description guest CPU kind */
                cpu_kind?: string;
                /** @description guest memory in megabytes */
                memory_mb?: number;
                /** @description guest CPU count */
                cpus?: number;
                /** @description guest GPU count */
                gpus?: number;
                /** @description guest GPU kind */
                gpu_kind?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["main.regionResponse"];
                };
            };
        };
    };
    Tokens_request_Kms: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description KMS token */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": string;
                };
            };
        };
    };
    Tokens_request_OIDC: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Optional request body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateOIDCTokenRequest"];
            };
        };
        responses: {
            /** @description OIDC token */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": string;
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    CurrentToken_show: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CurrentTokenResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
}
